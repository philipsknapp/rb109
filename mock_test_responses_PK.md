1. This code returns an Array object `[1, 3, 5, 7, 9]`. On line 1, we initialize the variable `arr` and assign it to an Array object of Integer objects. On line 2, we call the method `select` on the collection referenced by `arr`, passing in the block on line 2 as an argument. `select` returns a new array, containing only those elements which, when the block is executed with the block parameter assigned to that element, cause the block to return a truthy value.  
Within the block, we call the `odd?` method on each element `n`, which will return `true` if the integer is an odd number. This is the last evaluated expression in the block, so the return value of `odd?` will be the return value of the block by implicit return.
The elements of the original array which cause the block to return `true` are `1`, `3`, `5`, `7`, and `9`; these will comprise the returned array.
This demonstrates the behavior of `select` when performing selection on a collection.
2. This code outputs and returns the array `[false, true, true, true, true, true, true, true, true, true]`. On line 1, we initialize the variable `arr` and assign it to an Array object of Integer objects. On line 2, we initialize another variable `new_array` and assign it to the return value of calling the method `map` on `arr`, passing in the block on lines 2-4 as an argument.
The return value of `map` is a new array with a number of elements equal to the number of elements in the collection it was called on. Each element of the new array is the return value of the block argument when evaluated for the corresponding element of the old array (assigning the block parameter `n` to that element). In this instance, the block returns `true` or `false` depending on whether the collection element is greater than `1`. `arr[0]` references `1`, so the block returns `false` for the 0th element; all 9 other elements of `arr` are greater than 1, so the block will return `true` for them. Therefore, the return value of `map` called on `arr` is `[false, true, true, ..., true]` as described above.
Finally, we call the method `p` with `new_array` (assigned to the return value of `map` ), which outputs and returns the object referenced by `new_array` , described at the top.
This demonstrates the important differences between transforming and selecting a collection; the block makes this look like a selection action at first glance, but `map` uses the block return value in a very different way from `select`.
3. This code returns the boolean object `true`. We call the `all?` method on a Hash object, passing a block as an argument. `all?` returns `true` only if every element in the collection it's called on causes the block to return a truthy value, and returns `false` otherwise.
The block uses the block parameters `|key, value|`; when iterating over the key/value pairs in the hash, `key` will be assigned to the key in the pair, while `value` will be assigned to the value. In the block, we call the `length` method on the value (our values are all strings, which have a `length` method defined, so this will not cause an error), and compare the resulting integer to `3`, returning `true` if the integer is greater than or equal to `3` and `false` otherwise.
In this hash, calling `length` on each value will return an integer greater than or equal to `3`; therefore, the block will return `true` for every element of the hash, meaning that `all?` returns `true`.
4. This code returns the hash { "ant" => :a, "bear" => :b, "cat" => c }. We call the method `each_with_object` on a Hash object, passing in an empty Hash object `{}` as one argument and a block as another argument. The block parameters are `|(key, value), hash|`; when iterating over the key/value pairs in the original hash, `key` will be assigned to the key in the pair, while `value` will be assigned to the value. `hash` is assigned to the Hash object passed as an argument to `each_with_object`, which will be mutated over the course of the method call and returned as the method's return value.
This code essentially swaps the key/value relationship from the old hash to the new hash. In each iteration of `each_with_object`, we assign a value associated with a new key in `hash`. The key is a value from the old hash, while the value is the corresponding key from the old hash. For instance, in the first iteration, we assign `:a` as the value associated with the key `"ant"`.
5. This code returns the array `[1, 2, 3]` and demonstrates the way that variables behave as pointers.
On line 1, we initialize the local variable `a` and assign it to the Array object `[1, 2, 3, 3]`. On line 2, we initialize the local variable `b` and assign it to the object referenced by `a`. `a` and `b` are now pointing to the same object in memory. On line 3, we initialize the local variable `c` and assign it to the return value of calling the `uniq` method on `a`. `uniq` returns a new array with the duplicate values removed; it does not mutate. Therefore, `a` and `b` still point to the same object `[1, 2, 3, 3]`, while `c` points to the new object `[1, 2, 3]`.
If the last line was `c = a.uniq!` the results would be quite different. `uniq!` is mutating, so calling it on `a` would cause the object referenced by `a` and `b` to change to `[1, 2, 3]`. `uniq!` also returns a reference to the caller, so `c` is assigned to point to the same object as `a`. All 3 variables will then point to the object `[1, 2, 3]`, illustrating how mutation can cause the values of multiple variables to change at once if they're pointing to the same object.
6. This code returns `'axc'`; both `s` and `t` reference this String object by the end of the code. We initialize the local variable `s` and assign it to the String object `'abc'`; we then initialize the local variable `t` and assign it to the return value of calling the `fix` method, passing in a reference to the object referenced by `s` as an argument.
In the method, we initialize the method parameter `value` and assign it to the object referenced by `s`, making `value` available as a local variable in the method. We then perform indexed assignment to change the 1st character in `value` to `'x'`, mutating `'abc'` to `'axc'`. Finally, we return the object referenced by `value` by implicit return; `t` is assigned to this object. Since this is also the object referenced by `s`, `t` and `s` are assigned to the same object. This again demonstrates the behavior of variables as pointers and the way that that interacts with mutation, as well as Ruby's object passing strategy which passes copies of references to objects around, allowing for mutation.
7. This code returns and outputs `"hello world"`, demonstrating the way Ruby's "pass by value of reference" object passing strategy allows methods to mutate with respect to their caller and arguments. On line 1, we initialize the local variable `a` and assign it to the String object `'hello'`. We then call `a_method`, passing in a reference to the object referenced by `a` as an argument. In the method, we initialize the method parameter `string` and assign it to the object referenced by `a`, making `string` available as a local variable in the method. We then use the `<<` method to mutate the object referenced by `string`; since `a` is referencing the same object, calling `a_method` changes its value, as demonstrated by calling `p` to output and return the value referenced by `a`.
8. This code returns `'HELLO!'` by implicit return (this is the value of `fix(s)`), demonstrating the fact that reassignment does not always change which object a variable is pointing at, as long as it's "reassigned" to the same location in memory it was already assigned to. On line 1, we initialize the local variable `s` and assign it to the String object `'hello'` . On line 2, we initialize the local variable `t` and assign it to the return value of calling the method `fix` , passing in a reference to the object referenced by `s` as an argument.
Within the method, we initialize the method parameter `value` and assign it to the object referenced by `s`, making `value` available as a local variable in the method. We seemingly reassign `value` to the return value of calling `upcase!` on `value`, but this doesnâ€™t tell the whole story. `upcase!` mutates the object referenced by `value` (and by `s`), and returns that same object, meaning the reassignment element of this line of code is similar to `value = value` - we're reassigning the object to itself.
We then perform a similar action on the next line, calling `concat` on `value` with the argument `'!'`. This again mutates the object referenced by `value` and `s`, and returns a reference to itself. By implicit return, this reference is the return value of the method, so `t` and `s` reference the same object.
9. This code outputs `Goodbye`, then `Hello`, and returns `nil` (as `puts` is our last evaluated expression and a `puts` method call always returns `nil`). This demonstrates the behavior of variables as pointers: we initialize `a` and assign it to the string object `"Hello"`, then initialize `b` and assign it to the object referenced by `a`; at this point `a` and `b` are pointing to the same object. We then reassign `a` to the String object `"Goodbye"`; this has no effect on `b`, which still points to `"Hello"`. Calling the `puts` method on each object shows which objects they're referencing.
10. This code returns the Array object `["hello", "hello", "hello"]` , demonstrating transformation with `map` as well as the way block scoping allows methods to interact with local variables outside the method. We initialize a local variable `a` and assign it to a String object `"hello"`. We then call `map` on an Array of 3 elements, passing in a block as an argument.
`map` returns a new array with a number of elements equal to the number of elements in the collection it was called on. Each element of the new array is the return value of the block argument when evaluated for the corresponding element of the old collection (assigning the block parameter `num` to that collection element). Here, the block parameter is not used; the block's only expression (and therefore, its return value), is the variable `a`. Because `a` was initialized outside the block scope, the block has access to it.
Because the return value of the block is `"hello"`, the code returns an array of 3 elements, each element having the value `"hello"`.
11. This code outputs `1`, then `2`, then `3`, and returns the array `[1, 2, 3]`. This demonstrates the behavior of the `each` method, which we call here on the Array object `[1, 2, 3]` and pass in a block. `each` executes its block once for each element of the collection it was called on, assigning the block parameter `num` to that collection element. This block simply calls `puts` with `num` as an argument, outputting each element of the original array in turn. (The block return value is `puts`'s return value, `nil`, but `each` does not use this return value for anything). `each` then returns the collection it was called on.
12. This code outputs and returns `[2, 3, 4, 5, 6, 7, 8, 9, 10, 11]` and demonstrates the use of `map` to transform a collection. We first initialize the local variable `arr` and assign it to an Array object collecting 10 Integer objects. We then initialize the local variable `incremented` and assign it to the return value of calling the `map` method on `arr`, passing in a block as an argument.`map` returns a new array with a number of elements equal to the number of elements in the collection it was called on. Each element of the new array is the return value of the block argument when evaluated for the corresponding element of the old collection (assigning the block parameter `n` to that collection element).
This block's return value, by implicit return, is the result of calling the `+` method on `n`, with `1` as an argument. On the first iteration, we set `num` equal to the object referenced by `arr[0]`, `1`, add 1 to it, and return the result of 2. Therefore, the 0th element of our returned array will be 2. All in all, this `map` call transforms the original array by incrementing each of its elements by 1.
We then call the method `p` with `incremented` as an argument, which outputs and returns the value `incremented` references: the new array returned by `map`.
13. This code outputs `5`, then throws an error, and demonstrates the scoping rules of blocks: specifically, that code outside a block cannot access variables initialized inside the block. On line 1, we initialize the local variable `a` and assign it to an Integer object `4`. We then call the method `loop`, passing in a block. Within the block, we reassign `a` to `5` and initialize the new local variable `b`, assigning it to another Integer `3`. The `break` statement takes us out of the loop (and out of the block).
When we call the `puts` method with `a` as an argument, it outputs `5`, the value `a` was reassigned to inside the block (since blocks can access variables initialized in their outer scope). However, when we call `puts` with `b` as an argument, there is no local variable `b`; it was initialized inside the block, and is now inaccessible. This causes an error.
14. This code outputs and returns `'Bill'`, demonstrating the block scoping rule that blocks can access (and therefore modify) local variables initialized in the outer scope of the block.
On line 1, we initialize the local variable `a` and assign it to the String object `'Bob'`. We then call the `times` method, passing in a block in which we reassign `a` to `'Bill'`. After the `times` method has executed this block `5` times (reassignments 2-5 do change the object in memory that `a` is referencing, but all of these objects have the same value), we call the `p` method with `a` as an argument. This returns and outputs the value of the object `a` references, which is `'Bill'`
15. This code outputs `'ab'`, demonstrating the behavior of methods that mutate with respect to their arguments. We initialize the local variable `y` and assign it to the String object `'a'`. We then call the method `increment`, passing in a reference to the object referenced by `y` as an argument.
In the method, we initialize the method parameter `x` and assign it to the argued reference, making it available to the method body as a local variable. We then call the `<<` method on `x`, with `'b'` as an argument; this mutates the object referenced by `x` (and by `y`), concatenating it to `'ab'`. Finally, outside the method, we call the `puts` method, passing in a reference to the object referenced by `y` as an argument. This outputs `'ab'`.
16. This code outputs (on successive lines) `a`, `b`, `c`, `A`, `B`, `C`, and demonstrates the utility of copying collections with `dup`, as well as the behavior of the mutating transformation method `map!`. We initialize the local variable `arr1` and assign it to the Array object `["a", "b", "c"]`. We then initialize the local variable `arr2` and assign it to the return value of calling the `dup` method on `arr1`. `dup` returns a copy of `arr1`, meaning that `arr1.dup` is equal to `arr1` but is a different object in memory; therefore, `arr1` and `arr2` are equal but do not point to the same object.
This means that when we call `map!` on `arr2`, passing in a block as an argument, we mutate `arr2` but do not alter the value of `arr1`. `map!` mutates the array it was called on, replacing each element with the return value of the block argument when evaluated for that element (assigning the block parameter `char` to that element). By implicit return, the return value of the block is the return value of calling the `upcase` method on `char`, meaning that `map!` replaces the one-character lowercase strings in `arr2` with their uppercase counterparts. Calling `puts` twice and passing in references to the objects referenced by `arr1` and `arr2`, respectively, outputs their contents, confirming this behavior.
17. This code outputs a string containing the sum of the elements of the local variable `arr`, `"Your total is 10"`, demonstrating the use of a loop to iterate over a collection. We initialize `arr` and assign it to the Array object `[1, 2, 3, 4]`. We then initialize and assign (to the Integer object `0`) two local variables, `counter` and `sum`, which we will use to track values over the iterations of the `loop` block below.
We then call the method `loop`, passing in a block as an argument. `loop` will execute this block repeatedly, until it executes a `break` statement. Within the loop, we first reassign `sum` to the sum of its current value and the value of the `arr` at index `counter`. On our first iteration, `arr[0]` is `1` and `sum` is `0`, so this reassigns `sum` to `1`. We then reassign `counter` to its current value plus `1`, incrementing it. Finally, we call `break` with a conditional modifier: we will only `break` if `counter` is equal to the return value of calling the method `size` on `arr`.
This is a typical way of using a loop to iterate over a collection: we use `counter` to access each element of `arr` in turn and perform some action on it. Then, when `counter` is too large to access an element of `arr` (remember that the elements of `arr` are at the indices 0, 1, 2, 3, while `arr.size` is 4), we break out of the loop. In this case, we add the value of each element of `arr` to the running total `sum`; since `counter` and `sum` are defined outside the `loop` block, the block has access to them (by block variable scoping rules), and the main method still has access to them once the block is complete.
Finally, we call `puts`, passing in a String object as an argument. The string uses variable interpolation with `#{}` to interpolate the final value of `sum` , leading to the output described above.
18. This code returns and outputs the Array `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` and demonstrates how the `select` method uses truthiness to construct its return value.
We first initialize the local variable `arr` and assign it to an Array with the value`[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]` (note that this is equal to the final return value of the code). We then initialize the local variable `new_array` and assign it to the return value of calling the method `select` on `arr`, passing in a block as an argument. `select` returns a new array, containing only those elements which, when the block is executed with the block parameter assigned to that element, cause the block to return a truthy value.
In this case, the block's return value will be (by implicit return) the return value of calling the `+` method on the block parameter `n`, with `1` as an argument. Because all of `arr`'s elements are integers, this will always return an integer. All integers (in fact, all object other than `false` and `nil`) are truthy. Therefore, `select` returns a new array containing all the elements of the array referenced by `arr`; `new_array` is assigned to this array. Calling `p` and passing in a reference to the object referenced by `new_arr` as an argument will output and return this object, demonstrating that it has the same value (but is not the same object) as the object `arr` was initially assigned to on line 1.
19. This code returns `true`, demonstrating the function of the `any?` in evaluating collections to Boolean objects. We call `any?` on the object `[1, 2, 3]`, passing in a block as an argument. `any?` will return `true` if any of the elements of the collection it was called on cause the block to return a truthy value when the block parameter `|num|` is assigned to that element; otherwise, it returns `false`.
Here, the block's only expression (and therefore, by implicit return, its return value) is `num > 2`, meaning it will return `true` if the block parameter `num` is greater than `2`, and `false` otherwise. This block returns `false` for the first two elements of the array `1` and `2`, but returns `true` for the last element, `3`; therefore, `any?` returns `true`.
20. This code returns `'HELLO!'`; at the end of the code, `s` has the value `'HELLO'` and `t` has the value `'HELLO!'`. This demonstrates how mutating and reassigning methods does and doesn't (respectively) alter what objects variables point to. We first initialize the local variable `s` and assign it to the object `'hello'`; we then initialize the local variable `t` and assign it to the return value of calling the `fix` method, passing in a reference to the object referenced by `s` as an argument.
In the method, we initialize the method parameter `value` and assign it to the argued reference, making it available to the method body as a local variable. We then call the `upcase!` method on `value`, which mutates the object `value` (and `s`) references to `'HELLO'`. Next, we reassign `value` to a new String, equal to the String referenced by `value` concatenated with `!`. Now, `value` is pointing at the new String `'HELLO!'` while `s` still references the old String `'HELLO'`. Our last line of the method is just `value`, which (by implicit return) returns a reference to the object referenced by `value`. `t` is assigned to this object, meaning `t` now equals `'HELLO!'`
21. This code outputs `3`, then `2`; the fact that it outputs `3` demonstrates that local variables initialized outside a block can be modified inside the block, as well as the way variables behave as pointers.
On lines 1 and 2, we initialize the local variables `a` and `b` and assign them to the Integer objects `4` and `2` respectively.
We then call `loop`, passing in a block as an argument. Within the block, we initialize a local variable `c` and assign it to the Integer object 3, then assign `a` to the same object `c` is referencing; `a` and `c` now both reference `3`.`break` takes us out of the block and the loop; we no longer have access to `c`, but `a` still references `3`. Calling `puts`, passing in a reference to the object referenced by `a` as an argument, confirms this by outputting `3`. Then, calling `puts` and passing in a reference to the object referenced by `b` as an argument outputs `2`; `b` was not altered at any point in this code.
22. This code outputs and returns `['a', '-', 'c']`, demonstrating the way indexed assignment mutates a collection. We first initialize the local variable `a`, using the shorthand `%w` to create the Array object ['a', 'b', 'c'] and assign `a` to it. We then use indexed assignment with `[]=` to reassign the first element of the array referenced by `a` to `'-'`. Note that this reassigns the individual array element, but mutates the array as a whole; `a[1].object_id` now has a different value, but `a.object_id` has the same value. Calling the method `p` and passing in a reference to the object referenced by `a` as an argument outputs and returns `['a', '-', 'c']`, confirming that the 1st element of `a` has been changed.
23. This code outputs (on successive lines) `bob` and `kim`, demonstrating the way that a line of code that looks like mutation can actually be reassignment. We initialize the we initialize the local variable `names` and assign it to the Array object `['bob', 'kim']`. We then call the method `add_name`, passing in two arguments: a reference to the object referenced by `names`, and the object '`jim'`.
In the method, we initialize the method parameter `arr` and assign it to the object referenced by `names`; we also initialize the parameter `name` and assign it to `'jim'`, making `arr` and `name` available to the method body as local variables. We reassign `arr` to a new array, the return value of concatenating `arr` and an array with one element, `name`, with the method `+`. `arr` has now been reassigned to the object `['bob', 'kim', 'jim']`, but the original array referenced by `names` has not been mutated. `add_name` returns the new array by implicit return, but our code does not use this return value. When we call the method `puts` and pass in a reference to the object referenced by `names` as an argument, the output shows us that `names` was not mutated by calling `add_name`.